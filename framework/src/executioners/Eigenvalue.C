//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include "Eigenvalue.h"
#include "EigenProblem.h"
#include "Factory.h"
#include "MooseApp.h"
#include "NonlinearEigenSystem.h"
#include "SlepcSupport.h"

registerMooseObject("MooseApp", Eigenvalue);

defineLegacyParams(Eigenvalue);

InputParameters
Eigenvalue::validParams()
{
  InputParameters params = Steady::validParams();

  params.addClassDescription(
      "Eigenvalue solves a standard/generalized linear or nonlinear eigenvaue problem");

  params.addParam<bool>(
      "matrix_free",
      false,
      "Whether or not to use a matrix free fashion to form operators. "
      "If true, shell matrices will be used and meanwhile a preconditioning matrix"
      "may be formed as well.");

  params.addParam<bool>(
      "precond_matrix_free",
      false,
      "Whether or not to use a matrix free fashion for forming the preconditioning matrix. "
      "If true, a shell matrix will be used for preconditioner.");

  params.addParam<bool>("precond_matrix_includes_eigen",
                        false,
                        "Whether or not to include eigen kernels in the preconditioning matrix. "
                        "If true, the preconditioning matrix will include eigen kernels.");

  params.addPrivateParam<bool>("_use_eigen_value", true);

  params.addParam<PostprocessorName>(
      "normalization", "Postprocessor evaluating norm of eigenvector for normalization");
  params.addParam<Real>(
      "normal_factor", 1.0, "Normalize eigenvector to make a defined norm equal to this factor");

  params.addParam<bool>("auto_initialization",
                        true,
                        "If true, we will set an initial eigen vector in moose, otherwise EPS "
                        "solver will initial eigen vector");

  // If Newton and Inverse Power is combined in SLEPc side
  params.addPrivateParam<bool>("_newton_inverse_power", false);

  params.addParam<bool>("output_inverse_eigenvalue",
                        false,
                        " Whether or not the system output the inverse of eigenvaue. It is useful "
                        "for neutronic simulation.");

  params.addParam<Real>("time", 0.0, "System time");

// Add slepc options and eigen problems
#ifdef LIBMESH_HAVE_SLEPC
  Moose::SlepcSupport::getSlepcValidParams(params);

  params += Moose::SlepcSupport::getSlepcEigenProblemValidParams();
#endif
  return params;
}

Eigenvalue::Eigenvalue(const InputParameters & parameters)
  : Executioner(parameters),
    _eigen_problem(*getCheckedPointerParam<EigenProblem *>(
        "_eigen_problem", "This might happen if you don't have a mesh")),
    _normalization(isParamValid("normalization") ? &getPostprocessorValue("normalization")
                                                 : nullptr),
    _system_time(getParam<Real>("time")),
    _time_step(_eigen_problem.timeStep()),
    _time(_eigen_problem.time()),
    _final_timer(registerTimedSection("final", 1))
{
// Extract and store SLEPc options
#if LIBMESH_HAVE_SLEPC
  Moose::SlepcSupport::storeSlepcOptions(_eigen_problem, parameters);

  Moose::SlepcSupport::storeSlepcEigenProblemOptions(_eigen_problem, parameters);
  _eigen_problem.setEigenproblemType(_eigen_problem.solverParams()._eigen_problem_type);

  // If need to initialize eigen vector
  _eigen_problem.needInitializeEigenVector(getParam<bool>("auto_initialization"));

  // Whether or not the system outputs the inverse of eigenvaue.
  // It is useful for neutron calculations. The inverse of the eigenvalue is the multiplication
  // factor.
  _eigen_problem.outputInverseEigenvalue(getParam<bool>("output_inverse_eigenvalue"));
#endif

  if (!parameters.isParamValid("normalization") && parameters.isParamSetByUser("normal_factor"))
    paramError("normal_factor",
               "Cannot set scaling factor without defining normalization postprocessor.");

  // _feproblem_solve calls FEProblemBase
  _picard_solve.setInnerSolve(_feproblem_solve);

  _time = _system_time;
}

void
Eigenvalue::init()
{
#ifdef LIBMESH_HAVE_SLEPC
  // Set a flag to nonlinear eigen system
  _eigen_problem.getNonlinearEigenSystem().precondMatrixIncludesEigenKernels(
      getParam<bool>("precond_matrix_includes_eigen"));
#endif
  if (_app.isRecovering())
  {
    _console << "\nCannot recover eigenvaue solves!\nExiting...\n" << std::endl;
    return;
  }

  // Does not allow time kernels
  checkIntegrity();
  // Some setup
  _eigen_problem.execute(EXEC_PRE_MULTIAPP_SETUP);
  _eigen_problem.initialSetup();

#ifdef LIBMESH_HAVE_SLEPC

  // Make sure all PETSc options are setup correctly
  prepareSolverOptions();

  // Let do an initial solve if a nonlinear eigen solver but not power is used.
  // The initial solver is a Inverse Power, and it is used to compute a good initial
  // guess for Newton
  auto free_power_iterations = getParam<unsigned int>("free_power_iterations");
  if (free_power_iterations
    && _eigen_problem.isNonlinearEigenvalueSolver()
    && _eigen_problem.solverParams()._eigen_solve_type != Moose::EST_NONLINEAR_POWER )
    {
      _eigen_problem.doInitialFreePowerIteration(true);
      // Set free power iterations
      setFreeNonlinearPowerIterations(free_power_iterations);
      // Provide vector of ones to solver
      if (_eigen_problem.needInitializeEigenVector())
        _eigen_problem.initEigenvector(1.0);

      _console << " Free power iteration starts" << std::endl;

      // Call solver
      _eigen_problem.solve();
      // Clear free power iterations
      clearFreeNonlinearPowerIterations();

      _eigen_problem.doInitialFreePowerIteration(false);
    }
 #endif
}

void
Eigenvalue::execute()
{
  // Recovering makes sense for only transient simulations since the solution from
  // the previous time steps is required.
  if (_app.isRecovering())
    return;

  // Several lines of code are needed to make the output system work (copy from "Steady")
  _time_step = 0;
  _time = _time_step;
  _eigen_problem.outputStep(EXEC_INITIAL);
  _time = _system_time;

  preExecute();

  // The following code of this function is copied from "Steady"
  // "Eigenvalue" implementation can be considered a one-time-step simulation to
  // have the code compatible with the rest moose world.
  _eigen_problem.advanceState();

  // First step in any eigenvalue state solve is always 1 (preserving backwards compatibility)
  _time_step = 1;

#ifdef LIBMESH_ENABLE_AMR

  // Define the refinement loop
  unsigned int steps = _eigen_problem.adaptivity().getSteps();
  for (unsigned int r_step = 0; r_step <= steps; r_step++)
  {
#endif // LIBMESH_ENABLE_AMR
    _eigen_problem.timestepSetup();

    // This loop is for nonlinear multigrids (developed by Alex)
    for (MooseIndex(_num_grid_steps) grid_step = 0; grid_step <= _num_grid_steps; ++grid_step)
    {

      // Let us do extra power iterations here if necessary
      auto extra_power_iterations = getParam<unsigned int>("extra_power_iterations");
      if (extra_power_iterations && _eigen_problem.isNonlinearEigenvalueSolver() &&
          _eigen_problem.solverParams()._eigen_solve_type != Moose::EST_NONLINEAR_POWER)
      {
        _eigen_problem.doInitialFreePowerIteration(true);
        // Set free power iterations
        setFreeNonlinearPowerIterations(extra_power_iterations);

        _console << " Extra Free power iteration starts" << std::endl;

        // Call solver
        _eigen_problem.solve();
        // Clear free power iterations
        clearFreeNonlinearPowerIterations();

        _eigen_problem.doInitialFreePowerIteration(false);
      }

      if (_eigen_problem.solverParams()._eigen_solve_type != Moose::EST_NONLINEAR_POWER)
        _console << " Nonlinear Newton iteration starts" << std::endl;
      else
        _console << " Nonlinear power iteration starts" << std::endl;

      _last_solve_converged = _picard_solve.solve();

      if (!lastSolveConverged())
      {
        _console << "Aborting as solve did not converge\n";
        break;
      }

      if (grid_step != _num_grid_steps)
        _eigen_problem.uniformRefine();
    }

    // Compute markers and indicators only when we do have at least one adaptivity step
    if (steps)
    {
      _eigen_problem.computeIndicators();
      _eigen_problem.computeMarkers();
    }
    // need to keep _time in sync with _time_step to get correct output
    _time = _time_step;
    _eigen_problem.outputStep(EXEC_TIMESTEP_END);
    _time = _system_time;

#ifdef LIBMESH_ENABLE_AMR
    if (r_step < steps)
    {
      _eigen_problem.adaptMesh();
    }

    _time_step++;
  }
#endif

  {
    TIME_SECTION(_final_timer)
    _eigen_problem.execMultiApps(EXEC_FINAL);
    _eigen_problem.execute(EXEC_FINAL);
    _time = _time_step;
    _eigen_problem.outputStep(EXEC_FINAL);
    _time = _system_time;
  }

  postExecute();
}

void
Eigenvalue::prepareSolverOptions()
{
#ifdef LIBMESH_HAVE_SLEPC
#if PETSC_RELEASE_LESS_THAN(3, 12, 0)
  // Make sure the SLEPc options are setup for this app
  Moose::SlepcSupport::slepcSetOptions(_eigen_problem, _pars);
#else
  // Options need to be setup once only
  if (!_eigen_problem.petscOptionsInserted())
  {
    // Master app has the default data base
    if (!_app.isUltimateMaster())
      PetscOptionsPush(_eigen_problem.petscOptionsDatabase());

    Moose::SlepcSupport::slepcSetOptions(_eigen_problem, _pars);

    if (!_app.isUltimateMaster())
      PetscOptionsPop();

    _eigen_problem.petscOptionsInserted() = true;
  }
#endif
#endif
}

void
Eigenvalue::postSolve()
{
#ifdef LIBMESH_HAVE_SLEPC
  if (_normalization)
  {
    Real val = getParam<Real>("normal_factor");

    if (MooseUtils::absoluteFuzzyEqual(*_normalization, 0.0))
      mooseError("Cannot normalize eigenvector by 0");
    else
      val /= *_normalization;

    if (!MooseUtils::absoluteFuzzyEqual(val, 1.0))
    {
      _eigen_problem.scaleEigenvector(val);
      // update all aux variables and user objects
      for (const ExecFlagType & flag : _app.getExecuteOnEnum().items())
        _eigen_problem.execute(flag);
    }
  }
#endif
}

void
Eigenvalue::setFreeNonlinearPowerIterations(unsigned int free_power_iterations)
{
#ifdef LIBMESH_HAVE_SLEPC
#if !PETSC_RELEASE_LESS_THAN(3, 12, 0)
  // Master app has the default data base
  if (!_app.isUltimateMaster())
    PetscOptionsPush(_eigen_problem.petscOptionsDatabase());
#endif

 Moose::SlepcSupport::setFreeNonlinearPowerIterations(free_power_iterations);

#if !PETSC_RELEASE_LESS_THAN(3, 12, 0)
 if (!_app.isUltimateMaster())
   PetscOptionsPop();
#endif
#endif
}

void
Eigenvalue::clearFreeNonlinearPowerIterations()
{
#ifdef LIBMESH_HAVE_SLEPC
#if !PETSC_RELEASE_LESS_THAN(3, 12, 0)
  // Master app has the default data base
  if (!_app.isUltimateMaster())
    PetscOptionsPush(_eigen_problem.petscOptionsDatabase());
#endif

 Moose::SlepcSupport::clearFreeNonlinearPowerIterations(_pars);

#if !PETSC_RELEASE_LESS_THAN(3, 12, 0)
 if (!_app.isUltimateMaster())
   PetscOptionsPop();
#endif
#endif
}

void
Eigenvalue::checkIntegrity()
{
  // check to make sure that we don't have any time kernels in eigenvaue simulation
  if (_eigen_problem.getNonlinearSystemBase().containsTimeKernel())
    mooseError("You have specified time kernels in your eigenvaue simulation");
}
